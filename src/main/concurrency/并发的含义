
并发（concurrency）：逻辑上具备同时处理多个任务的能力。
并行（parallesim）：物理上在同一时刻执行多个并发任务。

简单来讲，并行是并发设计的理想执行模式

多线程或多进程是并行的基本条件，但单线程也可用协程（coroutine）做到并发。尽管协程在单个线程上通过主动切换来实现多任务并发，但它也有自己的优势。
除了将因阻塞而浪费的时间找回来外，还免去了线程切换开销，有着不错的执行效率。协程上运行的多个任务本质上是依旧串行的，加上可控自主调度，所以并不需要做同步处理。

即便采用多线程也未必就能并行。Python就因GIL限制，默认只能并发而不能并行，所以很多时候转而使用“多进程+协程”架构

很难说哪种方式更好一些，它们有各自适用的场景。
通常情况下，用多进程来实现分布式和负载平衡，减轻单进程垃圾回收压力；
用多线程（LWP）抢夺更多的处理器资源；
用协程来提高处理器时间片利用率；

简单将goroutine归纳为协程并不合适。
运行时会创建多个线程来执行并发任务，且任务单元可被调度到其他线程并行执行。
这更像是多线程和协程的综合体，能最大限度提升执行效率，发挥多核处理能力。

go关键字执行流程：
关键字go并非执行并发操作，而是创建一个并发任务单元。新建任务被放置在系统队列中，等待调度器安排合适系统线程去获取执行权。
当前流程不会阻塞，不会等待该任务启动，且运行时也不保证并发任务的执行次序。

每个任务单元除保存函数指针、调用参数外，还会分配执行所需的栈内存空间。
相比系统默认MB级别的线程栈，goroutine自定义栈初始仅须2 KB，所以才能创建成千上万的并发任务。
自定义栈采取按需分配策略，在需要时进行扩容，最大能到GB规模。

与defer一样，goroutine也会因“延迟执行”而立即计算并复制执行参数。


